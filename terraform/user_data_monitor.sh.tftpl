#!/bin/bash
# Redireciona toda a saida (stdout e stderr) para um ficheiro de log para depuracao
exec > /var/log/user_data_output.log 2>&1

set -e

echo "--- Starting user_data script (Final version with correct token injection) ---"

# --- 1. INSTALL DEPENDENCIES ---
echo "Waiting and updating packages..."
sleep 15
apt-get update -y
echo "Installing Docker, Docker Compose, and Git..."
apt-get install -y docker.io docker-compose git

# --- 2. CREATE CONFIGURATION FILES ---
echo "Creating config directory /opt/monitoring..."
mkdir -p /opt/monitoring

# --- prometheus.yml ---
echo "Creating /opt/monitoring/prometheus.yml with authentication..."
# CORRECAO: Usamos <<EOF (sem aspas) para permitir a expansao da variavel ${do_token}
cat <<EOF > /opt/monitoring/prometheus.yml
global:
  scrape_interval: 15s
alerting:
  alertmanagers:
    - static_configs:
        - targets: ['alertmanager:9093']
rule_files:
  - /etc/prometheus/rules.yml
scrape_configs:
  - job_name: 'tcc-web'
    digitalocean_sd_configs:
      - port: 8080
        bearer_token: '${do_token}'
    relabel_configs:
      - source_labels: [__meta_digitalocean_tags]
        regex: '.*,tcc-autohealing-web,.*'
        action: keep
      - source_labels: [__meta_digitalocean_private_ip]
        target_label: __address__
        # CORRECAO: Escapamos o $1 para que seja interpretado pelo Prometheus e nao pelo shell
        replacement: '\${1}:8080'
EOF

# --- rules.yml (sem mudancas) ---
cat <<'EOF' > /opt/monitoring/rules.yml
groups:
  - name: TCCAlerts
    rules:
      - alert: TccWebAppDown
        expr: up{job="tcc-web"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Aplicacao TCC Web esta offline em {{ $labels.instance }}"
EOF

# --- alertmanager.yml (sem mudancas) ---
cat <<'EOF' > /opt/monitoring/alertmanager.yml
route:
  receiver: 'webhook-healer'
receivers:
  - name: 'webhook-healer'
    webhook_configs:
      - url: 'http://healer:5001/webhook'
EOF

# --- healer.py (sem mudancas) ---
cat <<'EOF' > /opt/monitoring/healer.py
from flask import Flask, request, jsonify
import subprocess, os, logging, threading
app = Flask(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
TERRAFORM_DIR = "/terraform_project/terraform"
WEB_COUNT = int(os.getenv("WEB_COUNT", "2"))
HEALING_IN_PROGRESS = threading.Lock()
def trigger_terraform_recreation():
    if not HEALING_IN_PROGRESS.acquire(blocking=False):
        app.logger.warning("Healing process already in progress.")
        return
    try:
        app.logger.info("Starting droplet recreation.")
        replace_args = []
        for i in range(WEB_COUNT):
            replace_args.extend(["-replace", f"digitalocean_droplet.web[{i}]"])
        cmd = ["terraform", "apply", "-auto-approve"] + replace_args
        env = os.environ.copy()
        proc = subprocess.run(
            cmd, cwd=TERRAFORM_DIR, capture_output=True,
            text=True, check=True, env=env
        )
        app.logger.info(f"Terraform executed: {proc.stdout}")
    except subprocess.CalledProcessError as e:
        app.logger.error(f"Terraform failed: {e.stderr}")
    except Exception as e:
        app.logger.error(f"Unexpected error: {e}")
    finally:
        HEALING_IN_PROGRESS.release()
@app.route('/webhook', methods=['POST'])
def webhook():
    data = request.json
    app.logger.info(f"Webhook received: {data.get('status')}")
    if data.get('status') == 'firing':
        threading.Thread(target=trigger_terraform_recreation).start()
    return jsonify({"status": "received"}), 200
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5001)
EOF

# --- .env file (sem mudancas) ---
echo "Creating environment file /opt/monitoring/.env..."
cat <<EOF > /opt/monitoring/.env
DO_TOKEN=${do_token}
EOF

# --- docker-compose.yml (sem mudancas) ---
echo "Creating /opt/monitoring/docker-compose.yml (using Quay.io mirror)..."
cat <<'EOF' > /opt/monitoring/docker-compose.yml
version: '3.7'
services:
  prometheus:
    image: quay.io/prometheus/prometheus:v2.51.2
    restart: always
    volumes:
      - /opt/monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - /opt/monitoring/rules.yml:/etc/prometheus/rules.yml
    ports:
      - '9090:9090'
    command: '--config.file=/etc/prometheus/prometheus.yml'
  
  alertmanager:
    image: quay.io/prometheus/alertmanager:v0.27.0
    restart: always
    volumes:
      - /opt/monitoring/alertmanager.yml:/etc/alertmanager/config.yml
    ports:
      - '9093:9093'
    command: '--config.file=/etc/alertmanager/config.yml'

  healer:
    image: python:3.11-slim
    restart: always
    volumes:
      - /opt/monitoring/healer.py:/app/healer.py
      - /opt/terraform_project:/terraform_project
    working_dir: /app
    command: sh -c "pip install flask && python healer.py"
EOF

# --- 3. EXECUTION ---
echo "Cloning the 'inserting-prometheus' branch from the repository..."
git clone -b inserting-prometheus https://github.com/arthur-calado/tcc-autohealing-do.git /opt/terraform_project

echo "Enabling Docker..."
systemctl enable --now docker

echo "Attempting to start services with Docker Compose (with retries)..."
max_attempts=5
attempt_num=1
until docker-compose -f /opt/monitoring/docker-compose.yml up -d
do
    if [ ${attempt_num} -eq ${max_attempts} ]; then
        echo "Error: Failed to start Docker services after ${max_attempts} attempts."
        exit 1
    fi
    echo "Attempt ${attempt_num} failed. Waiting 30 seconds to retry..."
    sleep 30
    attempt_num=$(( attempt_num+1 ))
done

echo "Docker services started successfully!"
echo "--- End of user_data script ---"